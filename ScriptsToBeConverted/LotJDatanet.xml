<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Monday, December 28, 2020, 10:11 PM -->
<!-- MuClient version 4.94 -->

<!-- Plugin "LotJDatanet" generated by Plugin Wizard -->

<muclient>
<plugin
   name="LotJDatanet"
   author="Fishy"
   id="79880fe93453b53e1f687076"
   language="Lua"
   purpose="LotJ Datanet tools"
   save_state="y"
   date_written="2020-12-28 22:08:13"
   requires="4.94"
   version="0.4"
   >
<description trim="y">
<![CDATA[
Clickable Datanet Hyperlinks:
Text in the format of "<clan>:/path/here" will automatically become a clickable hyperlink allowing you to view the indicated Datanet page.

]]>
</description>
</plugin>


<!--  Get our standard constants -->

<include name="constants.lua"/>

<!--  Triggers  -->

<triggers>
  <trigger
   enabled="y"
   match="(?:(&quot;\w+.*?\w+&quot;|&apos;\w+.*?\w+&apos;|\w+?)?):(\/(?:(\w|\d|_)+?\/?)+)"
    omit_from_output="y"
    ignore_case="y"
    regexp="y"
    script="onDRL"
    sequence="110"
  >
  </trigger>
</triggers>

<!--  Aliases  -->

<aliases>

</aliases>

<!--  Script  -->


<script>
<![CDATA[
-- Parsing into clickable hyperlinks while retaining styling.
-- This is a lightly modified copy of Sketch's handy Hyperlink_URL2

-- Returns an array {start, end, text}
function findDRLs(text)
	local DRLs = {}
	local start, position = 0, 0
	-- "rex" is a table supplied by MUSHclient for PCRE functionality.
	local re = rex.new("(?:(\"\\w+.*?\\w+\"|\'\\w+.*?\\w+\'|\\w+?)?):(\\/(?:(\\w|\\d|_)+?\\/?)+)")
	re:gmatch(text,
		function (link, t)
			if t[1] ~= false then clan = t[1] else clan = "" end
			start, position = string.find(text, link, position, true)
			table.insert(DRLs, {start=start, stop=position, text=link, clan=clan, path = t[2]})
		end
	)
	
	return DRLs
end -- function findDRL

-- Returns a table of points where formatting should change in the new string.
function getpoints(styles, hyperlinks)
	local points = {}
	local unique_points = {}
	local pos = 1
	for _,v in pairs(styles) do
		table.insert(points, pos)
		table.insert(points, pos + v.length)
		pos = pos + v.length
	end
	-- The last value of points is now 1 past the end of the string.

	for _,v in pairs(hyperlinks) do
		table.insert(points, v.start)
		table.insert(points, v.stop + 1)
		-- The hyperlink itself is at v.stop. v.stop+1 is where the change is.
	end

	table.sort(points)
	return unique_array(points)
end -- function getpoints

-- Returns an array with consecutive duplicate items removed.
function unique_array(a)
	local uniq, current = {}, nil
	for _,v in pairs(a) do
		if v ~= current then
			table.insert(uniq, v)
			current = v
		end
	end
return uniq
end -- function unique_array

-- Given an array of numbers, return an array of pairs, to be used in string.sub().
-- Each pair starts at the original array's key, and ends before the next key.
-- Example: [1, 5, 9, 13] --> [{1,4},{5,8},{9,12}]
function getslices(points)
	local newpoints = {}
	for i = 1, #points - 1, 1 do
		table.insert(newpoints, {start=points[i], stop=points[i+1] - 1})
	end
	return newpoints
end -- function getslices

-- Returns an array of
-- {startpos, endpos, textcolour, backcolour, style, hyperlink_number}
function reformat(slices, styles, hyperlinks)
	local styles_i, hyperlinks_i = 1, 1
	local hyperlink_number = 0
	local reformatted = {}
	-- nextstyle is set at the character where the next style begins.
	local nextstyle = styles[1].length + 1

	-- Add a fake hyperlink past the end of the string at the end of the array.
	-- This way, we don't have to keep checking (hyperlinks_i > #hyperlinks).
	table.insert(hyperlinks,{start=slices[#slices].stop + 1,stop=slices[#slices].stop + 1,text="",clan="", path = ""})

	for _,v in pairs(slices) do

		-- v.start is our 'current position'.
		-- Make sure we're using the correct style
		if v.start >= nextstyle then
			nextstyle = v.start + styles[styles_i + 1].length
			styles_i = styles_i + 1
		end

		-- If we've passed the hyperlink marked by hyperlinks_i, increment it.
		if v.start > hyperlinks[hyperlinks_i].stop then
			hyperlinks_i = hyperlinks_i + 1
		end

		-- The hyperlink_number is set to the hyperlink we're checking for if
		-- we're at or past its starting position. (In other words, inside it)
		if v.start >= hyperlinks[hyperlinks_i].start then
			hyperlink_number = hyperlinks_i
		else
			hyperlink_number = 0
		end

		table.insert(reformatted,
			{startpoint = v.start
			,endpoint = v.stop
			,textcolour = styles[styles_i].textcolour
			,backcolour = styles[styles_i].backcolour
			,style = styles[styles_i].style
			,hyperlink_number = hyperlink_number}
		)
	end
	return reformatted
end -- function reformat

-- Line: Whole line that contains the trigger, in plaintext.
-- Styles: [{textcolour, backcolour, text, length, style},...]
function onDRL (name, line, wildcards, styles)
	local hyperlinks = findDRLs(line)
	local reformatted = reformat(getslices(getpoints(styles,hyperlinks)), styles, hyperlinks)

	for _,v in pairs(reformatted) do
		NoteStyle(v.style) -- Set style for the segment, regardless of type.
		if v.hyperlink_number ~= 0 then
			-- Hyperlink(
				-- "datanet -c "..hyperlinks[v.hyperlink_number].clan.." view 
				-- "..hyperlinks[v.hyperlink_number].path -- Hyperlink
				-- ,string.sub(line, v.startpoint, v.endpoint) -- Displayed text
				-- ,"Datanet: " .. hyperlinks[v.hyperlink_number].clan.." Path:
				-- "..hyperlinks[v.hyperlink_number].path -- Hover text
				-- ,RGBColourToName(v.textcolour) -- Foreground color
				-- ,RGBColourToName(v.backcolour) -- Background color
				-- ,0 -- Boolean: Open in browser? No!
			-- )
						Hyperlink(
				"datanet "..hyperlinks[v.hyperlink_number].text -- Hyperlink
				,string.sub(line, v.startpoint, v.endpoint) -- Displayed text
				,"Datanet: " .. hyperlinks[v.hyperlink_number].text -- Hover text
				,RGBColourToName(v.textcolour) -- Foreground color
				,RGBColourToName(v.backcolour) -- Background color
				,0 -- Boolean: Open in browser? No!
			)
		else
			ColourTell(
				RGBColourToName(v.textcolour) -- Foreground color
				,RGBColourToName(v.backcolour) -- Background color
				,string.sub(line, v.startpoint, v. endpoint) -- Displayed text
			)
		end
	end
	Note ("") -- Insert a newline at the end of the string.  
end -- function onDRL
]]>
</script>


</muclient>
